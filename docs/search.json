[
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "Appendix 2: Creating your own spatial data",
    "section": "",
    "text": "pacman::p_load(tidyverse, sf, rnaturalearth, patchwork, prioritizr)\nsource(\"utils-functions.R\")\n\n\n\n\n\ndat_bndry &lt;- tibble(x = 100, y = seq(-50, 0, by = 1)) %&gt;%\n  bind_rows(tibble(x = seq(100, 160, by = 1), y = 0)) %&gt;%\n  bind_rows(tibble(x = 160, y = seq(0, -50, by = -1))) %&gt;%\n  bind_rows(tibble(x = seq(160, 100, by = -1), y = -50)) %&gt;%\n  as.matrix() %&gt;%\n  list() %&gt;%\n  st_polygon() %&gt;%\n  st_sfc(crs = \"EPSG:4326\") %&gt;%\n  st_sf() %&gt;%\n  st_make_valid()\n\n\n\n\n\ndat_PUs &lt;- st_make_grid(dat_bndry, cellsize = 2) %&gt;%\n  st_sf() %&gt;%\n  mutate(cellID = row_number()) # Add a cell ID reference\n\n\nggplot() +\n  geom_sf(data = dat_PUs)\n\n\n\n\n\n\n\n\n\n\n\n\ndat_species_prob &lt;- dat_PUs %&gt;%\n  st_sf() %&gt;%\n  mutate(\n    Spp1 = runif(n = dim(.)[[1]]),\n    Spp2 = runif(n = dim(.)[[1]]),\n    Spp3 = runif(n = dim(.)[[1]]),\n    Spp4 = runif(n = dim(.)[[1]]),\n    Spp5 = runif(n = dim(.)[[1]])\n  )\nprint(dat_species_prob)\n\nSimple feature collection with 780 features and 6 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 100 ymin: -50 xmax: 160 ymax: 2\nGeodetic CRS:  WGS 84\nFirst 10 features:\n   cellID                       geometry       Spp1      Spp2       Spp3\n1       1 POLYGON ((100 -50, 102 -50,... 0.05142631 0.8430771 0.70022472\n2       2 POLYGON ((102 -50, 104 -50,... 0.97343994 0.5730945 0.13078406\n3       3 POLYGON ((104 -50, 106 -50,... 0.16209232 0.2156297 0.07623968\n4       4 POLYGON ((106 -50, 108 -50,... 0.99357504 0.1757342 0.57263289\n5       5 POLYGON ((108 -50, 110 -50,... 0.62700494 0.2351611 0.64400216\n6       6 POLYGON ((110 -50, 112 -50,... 0.96167113 0.4251205 0.93815500\n7       7 POLYGON ((112 -50, 114 -50,... 0.40675862 0.6831351 0.14574550\n8       8 POLYGON ((114 -50, 116 -50,... 0.24070468 0.2318140 0.60293214\n9       9 POLYGON ((116 -50, 118 -50,... 0.46935791 0.5162285 0.64300944\n10     10 POLYGON ((118 -50, 120 -50,... 0.55245805 0.9820114 0.85452307\n         Spp4        Spp5\n1  0.05564306 0.494363241\n2  0.70218158 0.935760281\n3  0.97100089 0.456492366\n4  0.05355954 0.003733954\n5  0.90780546 0.292877974\n6  0.38381572 0.357232457\n7  0.43944542 0.090834232\n8  0.44066742 0.065100683\n9  0.31681753 0.929851249\n10 0.11625105 0.575253925\n\n\n\n\n\n\ndat_species_bin &lt;- dat_species_prob %&gt;%\n  as_tibble() %&gt;%\n  mutate(across(\n     # Apply to all columns except geometry and cellID\n    -any_of(c(\"cellID\", \"geometry\")),\n    ~ case_when(\n      . &gt;= 0.5 ~ 1,\n      . &lt; 0.5 ~ 0,\n      is.na(.data) ~ 0\n    )\n  )) %&gt;%\n  st_as_sf()\n\n\n\n\nExtract feature names for use in prioritization\n\ncol_name &lt;- dat_species_bin %&gt;%\n  select(-\"cellID\") %&gt;%\n  st_drop_geometry() %&gt;%\n  colnames()\n\nAdd a cost layer\n\nout_sf &lt;- dat_species_bin %&gt;%\n  mutate(CostArea = rep(1, 780))\n\nCreate targets object\n\ntargets &lt;- rep(0.3, length(col_name))\n\nCreate a conservation problem\n\ndat_problem &lt;- problem(out_sf,\n                       features = col_name,\n                       cost_column = \"CostArea\"\n) %&gt;%\n  add_min_set_objective() %&gt;%\n  add_relative_targets(targets) %&gt;%\n  add_binary_decisions() %&gt;%\n  add_default_solver(verbose = FALSE)\n\n\n\n\nSolve and plot conservation problem\n\ndat_soln &lt;- dat_problem %&gt;%\n  solve.ConservationProblem()\n\n(gg_sol &lt;- splnr_plot_Solution(dat_soln))\n\nWarning: Duplicated `override.aes` is ignored."
  },
  {
    "objectID": "data.html#load-the-required-pacakges",
    "href": "data.html#load-the-required-pacakges",
    "title": "Appendix 2: Creating your own spatial data",
    "section": "",
    "text": "pacman::p_load(tidyverse, sf, rnaturalearth, patchwork, prioritizr)\nsource(\"utils-functions.R\")"
  },
  {
    "objectID": "data.html#create-a-dataset-boundary",
    "href": "data.html#create-a-dataset-boundary",
    "title": "Appendix 2: Creating your own spatial data",
    "section": "",
    "text": "dat_bndry &lt;- tibble(x = 100, y = seq(-50, 0, by = 1)) %&gt;%\n  bind_rows(tibble(x = seq(100, 160, by = 1), y = 0)) %&gt;%\n  bind_rows(tibble(x = 160, y = seq(0, -50, by = -1))) %&gt;%\n  bind_rows(tibble(x = seq(160, 100, by = -1), y = -50)) %&gt;%\n  as.matrix() %&gt;%\n  list() %&gt;%\n  st_polygon() %&gt;%\n  st_sfc(crs = \"EPSG:4326\") %&gt;%\n  st_sf() %&gt;%\n  st_make_valid()"
  },
  {
    "objectID": "data.html#create-planning-units",
    "href": "data.html#create-planning-units",
    "title": "Appendix 2: Creating your own spatial data",
    "section": "",
    "text": "dat_PUs &lt;- st_make_grid(dat_bndry, cellsize = 2) %&gt;%\n  st_sf() %&gt;%\n  mutate(cellID = row_number()) # Add a cell ID reference\n\n\nggplot() +\n  geom_sf(data = dat_PUs)"
  },
  {
    "objectID": "data.html#create-species-data",
    "href": "data.html#create-species-data",
    "title": "Appendix 2: Creating your own spatial data",
    "section": "",
    "text": "dat_species_prob &lt;- dat_PUs %&gt;%\n  st_sf() %&gt;%\n  mutate(\n    Spp1 = runif(n = dim(.)[[1]]),\n    Spp2 = runif(n = dim(.)[[1]]),\n    Spp3 = runif(n = dim(.)[[1]]),\n    Spp4 = runif(n = dim(.)[[1]]),\n    Spp5 = runif(n = dim(.)[[1]])\n  )\nprint(dat_species_prob)\n\nSimple feature collection with 780 features and 6 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 100 ymin: -50 xmax: 160 ymax: 2\nGeodetic CRS:  WGS 84\nFirst 10 features:\n   cellID                       geometry       Spp1      Spp2       Spp3\n1       1 POLYGON ((100 -50, 102 -50,... 0.05142631 0.8430771 0.70022472\n2       2 POLYGON ((102 -50, 104 -50,... 0.97343994 0.5730945 0.13078406\n3       3 POLYGON ((104 -50, 106 -50,... 0.16209232 0.2156297 0.07623968\n4       4 POLYGON ((106 -50, 108 -50,... 0.99357504 0.1757342 0.57263289\n5       5 POLYGON ((108 -50, 110 -50,... 0.62700494 0.2351611 0.64400216\n6       6 POLYGON ((110 -50, 112 -50,... 0.96167113 0.4251205 0.93815500\n7       7 POLYGON ((112 -50, 114 -50,... 0.40675862 0.6831351 0.14574550\n8       8 POLYGON ((114 -50, 116 -50,... 0.24070468 0.2318140 0.60293214\n9       9 POLYGON ((116 -50, 118 -50,... 0.46935791 0.5162285 0.64300944\n10     10 POLYGON ((118 -50, 120 -50,... 0.55245805 0.9820114 0.85452307\n         Spp4        Spp5\n1  0.05564306 0.494363241\n2  0.70218158 0.935760281\n3  0.97100089 0.456492366\n4  0.05355954 0.003733954\n5  0.90780546 0.292877974\n6  0.38381572 0.357232457\n7  0.43944542 0.090834232\n8  0.44066742 0.065100683\n9  0.31681753 0.929851249\n10 0.11625105 0.575253925"
  },
  {
    "objectID": "data.html#convert-to-binary-data",
    "href": "data.html#convert-to-binary-data",
    "title": "Appendix 2: Creating your own spatial data",
    "section": "",
    "text": "dat_species_bin &lt;- dat_species_prob %&gt;%\n  as_tibble() %&gt;%\n  mutate(across(\n     # Apply to all columns except geometry and cellID\n    -any_of(c(\"cellID\", \"geometry\")),\n    ~ case_when(\n      . &gt;= 0.5 ~ 1,\n      . &lt; 0.5 ~ 0,\n      is.na(.data) ~ 0\n    )\n  )) %&gt;%\n  st_as_sf()"
  },
  {
    "objectID": "data.html#setup-prioritization",
    "href": "data.html#setup-prioritization",
    "title": "Appendix 2: Creating your own spatial data",
    "section": "",
    "text": "Extract feature names for use in prioritization\n\ncol_name &lt;- dat_species_bin %&gt;%\n  select(-\"cellID\") %&gt;%\n  st_drop_geometry() %&gt;%\n  colnames()\n\nAdd a cost layer\n\nout_sf &lt;- dat_species_bin %&gt;%\n  mutate(CostArea = rep(1, 780))\n\nCreate targets object\n\ntargets &lt;- rep(0.3, length(col_name))\n\nCreate a conservation problem\n\ndat_problem &lt;- problem(out_sf,\n                       features = col_name,\n                       cost_column = \"CostArea\"\n) %&gt;%\n  add_min_set_objective() %&gt;%\n  add_relative_targets(targets) %&gt;%\n  add_binary_decisions() %&gt;%\n  add_default_solver(verbose = FALSE)"
  },
  {
    "objectID": "data.html#run-prioritization",
    "href": "data.html#run-prioritization",
    "title": "Appendix 2: Creating your own spatial data",
    "section": "",
    "text": "Solve and plot conservation problem\n\ndat_soln &lt;- dat_problem %&gt;%\n  solve.ConservationProblem()\n\n(gg_sol &lt;- splnr_plot_Solution(dat_soln))\n\nWarning: Duplicated `override.aes` is ignored."
  },
  {
    "objectID": "software.html",
    "href": "software.html",
    "title": "Appendix 1: Software installation",
    "section": "",
    "text": "While some software tools for conservation planning (e.g. Marxan or Zonation) do not require coding skills beyond GIS skills for input data preparation, prioritizr, the tool that we will be using today, is written in R and therefore requires a basic understanding of the R programming language. This allows for fast and reproducible workflows by exploiting the advantages of the programming language. It also allows pre- and post-processing of your data, all in R.\nTherefore, we need to install R, RStudio, and some other requirements for using prioritizr.\n\n\nInstalling R on your machine is straightforward. Follow these steps:\n\nGo to the CRAN (Comprehensive R Archive Network) R website. If you type “r” into Google it is the first entry\nChoose to download R for Linux, Mac or Windows\nFor Windows users, just install “base” and this will link you to the download file\nFor Mac users, choose the version relevant to your operating system, noting that if you have a new M1- or M2-powered Mac, you will need to download the Arm version\nIf you are a Linux user, you know what to do!\n\nIf you already have R installed, please make sure it has been updated recently.\n\n\n\nWe will use RStudio in this workshop. RStudio is a free front-end to R for Windows, Mac or Linux (i.e., R is working in the background). It makes working with R easier, more productive and more organised, especially for new users. There are other front-ends, but RStudio is the most popular. To install:\n\nGo to the RStudio download website\nChoose the Download button from the menu at the top, right-hand corner of the page\nChoose the Download button beneath RStudio Desktop\n\nDownload the correct version for your operating system\nInstall, and you’re ready to go!\n\n\n\n\nRStudio has four main panes each in a quadrant of your screen. You can set what appears in each (through Tools/Options menu in Windows or RStudio/Preference on a Mac), but the default has:\n\nConsole (bottom left)\nSource editor (top left)\nEnvironment and History (top right), and\nPlots, Files, Packages, Help, Viewer (bottom right).\n\n\n\n\nA really good R package to install the versions of the R packages that are in CRAN is pacman. We are going to install and load packages throughout the course of this workshop, but a common best practice is to install and load all necessary packages to run each script at the top of the R script.\nTo work through these notes you will need to install the add-on packages tidyr, ggplot2 and dplyr. Or you can just get the package tidyverse which has these and more. We also need some packages for spatial data and spatial data wrangling (sfand rnaturalearth) and a few more for data visualisation (patchwork and viridis). And of course we need prioritizr, which we will use for conservation planning.\n::: {.cell}\ninstall.packages(\"pacman\")\npacman::p_load(tidyverse, sf, rnaturalearth, patchwork, prioritizr, viridis)\n:::\n\n\n\nSolving conservation problems with prioritizr also requires having a solver installed on your machine. Solvers use specific algorithms that use mathematical optimization to find an optimal solution to a problem. There are many different solvers available that differ in terms of their efficiency and cost. The best solvers are usually expensive to use, but there are some good free ones available. For some more information on solver comparisons, see this article by Jeff Hanson, the developer of prioritizr.\nFor the purpose of this workshop, we recommend using one of the freely available solvers that are supported by prioritizr and are easily installed, such as the SYMPHONY solver, which can be installed using.\nIf you are a Windows user, lpsympony might work better. Check their website for more details: https://www.bioconductor.org/packages/release/bioc/html/lpsymphony.html\n\nif (!require(remotes)) install.packages(\"remotes\")\nremotes::install_bioc(\"lpsymphony\")\n\nIf you are a Mac/Linux, rcbc might work better. Check their README for more details https://github.com/dirkschumacher/rcbc\n\nif (!require(remotes)) install.packages(\"remotes\")\nremotes::install_github(\"dirkschumacher/rcbc\")\n\nAlternatively, if the installation fails for some reason, on your machine, try installing the HiGHS solver.\n\ninstall.packages(\"highs\")\n\nIf you are affiliated with an academic institution, you might have access to a free academic license of Gurobi, one of the state-of-the-art solvers out there. While we will not go through a step-by-step guide on how to install Gurobi here, there are many resources on how to install Gurobi, for example this installation guide on the prioritizr website. We recommend using this solver if you have access to it and want to use conservation planning for projects after this workshop."
  },
  {
    "objectID": "software.html#installation",
    "href": "software.html#installation",
    "title": "Appendix 1: Software installation",
    "section": "",
    "text": "Installing R on your machine is straightforward. Follow these steps:\n\nGo to the CRAN (Comprehensive R Archive Network) R website. If you type “r” into Google it is the first entry\nChoose to download R for Linux, Mac or Windows\nFor Windows users, just install “base” and this will link you to the download file\nFor Mac users, choose the version relevant to your operating system, noting that if you have a new M1- or M2-powered Mac, you will need to download the Arm version\nIf you are a Linux user, you know what to do!\n\nIf you already have R installed, please make sure it has been updated recently."
  },
  {
    "objectID": "software.html#installing-rstudio",
    "href": "software.html#installing-rstudio",
    "title": "Appendix 1: Software installation",
    "section": "",
    "text": "We will use RStudio in this workshop. RStudio is a free front-end to R for Windows, Mac or Linux (i.e., R is working in the background). It makes working with R easier, more productive and more organised, especially for new users. There are other front-ends, but RStudio is the most popular. To install:\n\nGo to the RStudio download website\nChoose the Download button from the menu at the top, right-hand corner of the page\nChoose the Download button beneath RStudio Desktop\n\nDownload the correct version for your operating system\nInstall, and you’re ready to go!"
  },
  {
    "objectID": "software.html#using-rstudio-a-quick-guide",
    "href": "software.html#using-rstudio-a-quick-guide",
    "title": "Appendix 1: Software installation",
    "section": "",
    "text": "RStudio has four main panes each in a quadrant of your screen. You can set what appears in each (through Tools/Options menu in Windows or RStudio/Preference on a Mac), but the default has:\n\nConsole (bottom left)\nSource editor (top left)\nEnvironment and History (top right), and\nPlots, Files, Packages, Help, Viewer (bottom right)."
  },
  {
    "objectID": "software.html#installing-required-r-packages",
    "href": "software.html#installing-required-r-packages",
    "title": "Appendix 1: Software installation",
    "section": "",
    "text": "A really good R package to install the versions of the R packages that are in CRAN is pacman. We are going to install and load packages throughout the course of this workshop, but a common best practice is to install and load all necessary packages to run each script at the top of the R script.\nTo work through these notes you will need to install the add-on packages tidyr, ggplot2 and dplyr. Or you can just get the package tidyverse which has these and more. We also need some packages for spatial data and spatial data wrangling (sfand rnaturalearth) and a few more for data visualisation (patchwork and viridis). And of course we need prioritizr, which we will use for conservation planning.\n::: {.cell}\ninstall.packages(\"pacman\")\npacman::p_load(tidyverse, sf, rnaturalearth, patchwork, prioritizr, viridis)\n:::"
  },
  {
    "objectID": "software.html#installing-a-solver",
    "href": "software.html#installing-a-solver",
    "title": "Appendix 1: Software installation",
    "section": "",
    "text": "Solving conservation problems with prioritizr also requires having a solver installed on your machine. Solvers use specific algorithms that use mathematical optimization to find an optimal solution to a problem. There are many different solvers available that differ in terms of their efficiency and cost. The best solvers are usually expensive to use, but there are some good free ones available. For some more information on solver comparisons, see this article by Jeff Hanson, the developer of prioritizr.\nFor the purpose of this workshop, we recommend using one of the freely available solvers that are supported by prioritizr and are easily installed, such as the SYMPHONY solver, which can be installed using.\nIf you are a Windows user, lpsympony might work better. Check their website for more details: https://www.bioconductor.org/packages/release/bioc/html/lpsymphony.html\n\nif (!require(remotes)) install.packages(\"remotes\")\nremotes::install_bioc(\"lpsymphony\")\n\nIf you are a Mac/Linux, rcbc might work better. Check their README for more details https://github.com/dirkschumacher/rcbc\n\nif (!require(remotes)) install.packages(\"remotes\")\nremotes::install_github(\"dirkschumacher/rcbc\")\n\nAlternatively, if the installation fails for some reason, on your machine, try installing the HiGHS solver.\n\ninstall.packages(\"highs\")\n\nIf you are affiliated with an academic institution, you might have access to a free academic license of Gurobi, one of the state-of-the-art solvers out there. While we will not go through a step-by-step guide on how to install Gurobi here, there are many resources on how to install Gurobi, for example this installation guide on the prioritizr website. We recommend using this solver if you have access to it and want to use conservation planning for projects after this workshop."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Conservation Planning for the Marine Environment",
    "section": "",
    "text": "Important\n\n\n\nWhile some software tools for conservation planning (e.g. Marxan or Zonation) do not require coding skills beyond GIS skills for input data preparation, prioritizr, the tool that we will be using today, is written in R and therefore requires a basic understanding of the R programming language. This allows for fast and reproducible workflows by exploiting the advantages of the programming language.\nTherefore, we need to install R, RStudio, and some other requirements for using prioritizr.\nPlease follow the software installation instructions in Appendix 1 before you attend the workshop."
  },
  {
    "objectID": "index.html#outline-for-today",
    "href": "index.html#outline-for-today",
    "title": "Conservation Planning for the Marine Environment",
    "section": "Outline for today:",
    "text": "Outline for today:\n\n\n\n\n\n\n\n\nTopic\nTime\nInstructor\n\n\n\n\nIntroduction\n08:00-08:05\nSandra and Ant\n\n\nTheory of Spatial Planning\n08:05-08:20\nJen\n\n\nCommon Spatial Prioritization tools\n08:20-08:30\nAnt\n\n\nSpatial Planning with prioritizr\n08:30 - 10:00\nSandra\n\n\nBreak\n10:00-10:20\n\n\n\nApplications of Marine Spatial Planning\n10:20-10:30\nAnt\n\n\nAdvanced Spatial Prioritization\n10:30-12:00\nSandra\n\n\nGoing beyond Code\n12:00-12:15\nAnt/Sandra/Alvise\n\n\nWrap up; Q&A\n12:15-12:30\nSandra and Ant"
  },
  {
    "objectID": "notes.html#study-site---the-galapagos",
    "href": "notes.html#study-site---the-galapagos",
    "title": "Conservation Planning for the Marine Environment",
    "section": "Study Site - The Galapagos",
    "text": "Study Site - The Galapagos\nToday you are a conservation officer helping plan the Galapagos Marine Reserve. The Galapagos Islands and surrounding waters are recognized globally for their unique species and biodiversity, such as the endemic giant tortoises, Galapagos penguins and marine iguanas. In 1998, the Ecuadorian Government created a marine reserve, covering 138,000 km2 around the islands, which at the time, made it the second largest marine reserve in the world. However, many of the species inhabiting Galapagos, such as the blue footed booby (Sula nebouxii) and silky shark (Carcharhinus falciformis), utilise the open ocean, and range outside the borders of the reserve. Thanks to tracking studies carried out over the quarter century since the creation of the reserve, we know much more about the movements of many of the species in and around the reserve, and can begin to address the question of whether the current reserve design provides adequate protection for them. We also know much more about the distribution of key ocean habitats in our region. Given that industrial and semi-industrial fishing pressure in Ecuador’s waters outside the reserve increased dramatically at the turn of the century, and that in recent years, large distant water fishing fleets have been reported in the high seas surrounding Ecuador’s Exclusive Economic Zone, the residents of Galapagos are concerned that the existing reserve may not provide sufficient protection to the ocean and wildlife that their livelihoods depend on. They are campaigning for an expansion of the reserve, and have asked us to identify key areas that should be included in their proposed new design. However, the fleets operating around the reserve are concerned that increasing the size of the reserve may affect their livelihoods. In addition to information on key habitats and species movements, we have obtained spatially explicit catch data from the two main fleets - the industrial tuna purse seine fleet and the national longline fleet for large pelagic species."
  },
  {
    "objectID": "notes.html#loading-preliminaries",
    "href": "notes.html#loading-preliminaries",
    "title": "Conservation Planning for the Marine Environment",
    "section": "Loading preliminaries",
    "text": "Loading preliminaries\nIt is best practice to load and define all “preliminaries” at the start of your R script. These preliminaries range from R packages to variables used across the R script, but typically it encompasses anything and everything that is used and reused throughout the R script.\nFirst, we load the necessary R packages. A really good R package to install the versions of the R packages that are in CRAN is pacman. We are going to install and load packages throughout the course of this workshop, but a common best practice is to install and load all necessary packages to run each script at the top of the R script.\n\ninstall.packages(\"pacman\")\n\nLoad the required packages and code. The code are custom utility functions that we have written to help automate certain tasks.\n\npacman::p_load(tidyverse, sf, rnaturalearth, patchwork, prioritizr, viridis)\nsource(\"utils-functions.R\")\n\nAnother best practice is to define the input paths as a variable to enhance the reproducibility of your R script. A good R package that breaches the difficulty of setting file paths in different Operating Systems (e.g., Windows syntax vs Mac), among other cool things, is the here R package. If you want to read more about the functionality of this package, take a look at their website.\n\ninputDat &lt;- file.path(\"Input\") # Define file paths\n\nNext, we define the Coordinated Reference System (CRS) that will be used throughout this R script. There are different ways to do this, but the two most common ones are using the EPSG code and the PROJ4 strings. Here’s a pdf that was prepared by M. Frazier and is freely available online that clearly explains the CRS syntax well. It is recommended to use the EPSG code or WKT (Well Known Text), but we find that using the PROJ4 string version of the CRS is useful for plotting maps that are not necessarily centered in the Meridian. But note PROJ4 is technically deprecated now so use with care.\nDefine CRS as the Mollweide Projection\n\ncCRS &lt;- \"ESRI:54009\" \n\n\n\n\n\n\n\nTypes of Spatial Data\n\n\n\nTo save time, we have pre-prepared the data for this workshop, but here we provide a brief overview of the types of data you will see, and the packages you can use to process them. Spatial data usually takes one of two forms — vector or raster.\nVector data is represented as points, lines, or polygons. Raster data is represented in grids of cells (i.e., pixels). There are pros and cons to each of the data formats, but the beauty of dealing with spatial data in R is that you can easily convert between the two forms of spatial data. Here, we show how you can load vector and raster data saved in different file formats. Vector data is usually saved as a shapefile (.shp) and attached to this are other files that contain the metadata (e.g., .shx, .dbf). All of these are usually in one folder. A useful R package to wrangle vector files is the sf R package. It is worth familiarizing yourself with this package.\n\nRaster data is usually saved as a GeoTIFF (Geo Tagged Image File Formats; .tiff). Another file format that is really good at compressing/storing large amounts of data is the netCDF (Network Common Data Form; .nc).\nA useful R package for wrangling raster files (and also vectors!) is the terraR package. stars is also a good R package and is particularly flexible and fast when dealing with rasters saved as netCDFs. Note that raster is an old R package that you might find in tutorials online, but it is best to not use this package anymore because it’s deprecated (i.e., support is discontinued for it). If you haven’t already, start transitioning to terra!\n\nSpatial data can also be stored as simple dataframes, with rows as either the vector units (points, lines, polygons) or raster units (grid cells) and the columns as the geographic coordinates of the units (latitude/longitude) and the attributes of each unit. Thus, we can load a simple .csv file with the geographic coordinates and transform it into an sf object (following an sf R package workflow) or a SpatRast/SpatVect (following a terra R package workflow). Here, we convert the data frame into an sf object."
  },
  {
    "objectID": "notes.html#loading-the-data",
    "href": "notes.html#loading-the-data",
    "title": "Conservation Planning for the Marine Environment",
    "section": "Loading the data",
    "text": "Loading the data\nBefore we can generate a spatial prioritization, we need to load the spatial data, which we have prepared.\nWe are using the Galapagos EEZ as our planning region (i.e., study area) and we have already created our planning units (i.e., smallest unit of the analysis) as hexagonal grids of 200km2 area. Hexagonal grids have the benefit that they fit around coastlines and boundaries better than square grids, but you can use either. We are defining our projection as the Mollweide equal-area projection. The PUs object contains planning units represented as spatial polygons (i.e., a sf::st_sf() object; Note that when using hexagonal planning units, you need to use sf). This object has two columns that denote the ID (cellID) and the outline of each planning unit (geometry).\n\nPUs &lt;- st_read(file.path(inputDat, \"PUs\", \"Galapagos_Planning_Units.shp\")) %&gt;%\n  st_transform(cCRS) %&gt;%\n  select(-\"cost\") %&gt;%\n  rename(cellID = puid)\n\nReading layer `Galapagos_Planning_Units' from data source \n  `/Users/eve067/GitHub/IMCC7_ConsPlanWorkshop/Input/PUs/Galapagos_Planning_Units.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 8749 features and 2 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: -95.42988 ymin: -4.83434 xmax: -85.87651 ymax: 5.068858\nGeodetic CRS:  WGS 84\n\nggplot() +\n  geom_sf(data = PUs)\n\n\n\n\n\n\n\n\nThe features object describes the spatial distribution of the features (i.e., the species, habitats or whatever we care about that would have corresponding targets). The feature data are also saved as an sf::st_sf() object. In addition to the cellID and geometry columns, each column corresponds to a feature we are interested in protecting. Values of the features denote the presence (using value of 1) or absence (using value of 0) across the study area.\n\nfeatures &lt;- readRDS(file.path(inputDat, \"Features\", \"Features_Combined.rds\"))\n\nLets have a look at some of the features using ggplot().\n\nggplot() +\n  geom_sf(data = features, aes(fill = tiger_shark))\n\n\n\n\n\n\n\nggplot() +\n  geom_sf(data = features, aes(fill = seamount))"
  },
  {
    "objectID": "notes.html#load-cost",
    "href": "notes.html#load-cost",
    "title": "Conservation Planning for the Marine Environment",
    "section": "Load Cost",
    "text": "Load Cost\nAs conservation and management actions are often restricted by costs, we therefore seek to meet targets, while minimizing costs and other impacts on industries, communities or other stakeholders. For this scenario, we will use the cost to the fishing industry. This is a layer that reflects the economic value derived within a given cell for the two primary fishing fleets operating in the Galapagos: the artisanal long-line pelagic fleet, and the industrial tuna purse-seine fleet.\nBecause there is no fishing allowed in the marine reserve, the cost is negligible and so prioritizr will preference meeting targets in these low-cost areas.\n\ncost &lt;- st_read(file.path(inputDat, \"Cost\", \"cost_surface.shp\")) %&gt;%\n  st_transform(cCRS) %&gt;%\n  rename(cellID = puid)\n\nReading layer `cost_surface' from data source \n  `/Users/eve067/GitHub/IMCC7_ConsPlanWorkshop/Input/Cost/cost_surface.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 8749 features and 2 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: -95.42988 ymin: -4.83434 xmax: -85.87651 ymax: 5.068858\nGeodetic CRS:  WGS 84\n\nggplot() +\n  geom_sf(data = cost, aes(fill = .data$cost))\n\n\n\n\n\n\n\n\nAdd cost to combined sf object.\n\nout_sf &lt;- features %&gt;%\n  left_join(cost %&gt;% sf::st_drop_geometry(), by = \"cellID\")\n\nGet the landmass.\n\nlandmass &lt;- rnaturalearth::ne_countries(\n  scale = \"medium\",\n  returnclass = \"sf\"\n) %&gt;%\n  sf::st_transform(cCRS)\nlandmass &lt;- rnaturalearth::ne_countries(\n  scale = \"medium\",\n  returnclass = \"sf\"\n) %&gt;%\n  sf::st_transform(cCRS)"
  },
  {
    "objectID": "notes.html#setup-prioritization",
    "href": "notes.html#setup-prioritization",
    "title": "Conservation Planning for the Marine Environment",
    "section": "Setup prioritization",
    "text": "Setup prioritization\nNow, we do the actual spatial prioritization. We are going to use the R package prioritizr to run the prioritizations. Apart from loading the spatial data, we need to prepare a couple of things for prioritizr. We first need to know the “names” (or their identifiers in the dataset) of the features.\n\n# Extract feature names\ncol_name &lt;- features %&gt;%\n  select(-\"cellID\") %&gt;%\n  st_drop_geometry() %&gt;%\n  colnames()\n\nWe then need the targets that we are assigning for each feature. Here, we show how we can assign equal targets for all features and how we can also assign different targets for different features. In a practical conservation planning setting, you would set higher targets to features that are more important.\n\n# Same target for all\ntargets &lt;- rep(0.3, length(col_name))\n\n\n# Assign higher target for species with tracking data\ntargets &lt;- data.frame(feature = col_name) %&gt;%\n  mutate(Category = c(rep(\"Geomorphic\", 12), rep(\"Tracking Data\", 5))) %&gt;%\n  mutate(target = if_else(Category == \"Tracking Data\", 50 / 100, 5 / 100))"
  },
  {
    "objectID": "notes.html#run-prioritsation",
    "href": "notes.html#run-prioritsation",
    "title": "Conservation Planning for the Marine Environment",
    "section": "Run prioritsation",
    "text": "Run prioritsation\nWe now have all the necessary information needed to run the prioritization. Next, we set up the conservation “problem” using problem() from prioritizr. In this function, we define all the spatial data (i.e., in this example, the object out_sf), what the features are called in out_sf, and the what the cost’s column name is in out_sf. We then use the minimum set objective function to solve this conservation problem (i.e., minimizing the cost while meeting all of the features’ targets) using add_min_set_objective(). We also assign the targets for each of the features using add_relative_targets(). The result of solving this conservation problem would be a binary one (1/0, yes/no, TRUE/FALSE), so the algorithm will assign whether a planning unit has been selected or not selected (using add_binary_decisions()).\n\ndat_problem &lt;- problem(out_sf,\n                       features = col_name,\n                       cost_column = \"cost\"\n) %&gt;%\n  add_min_set_objective() %&gt;%\n  add_relative_targets(targets$target) %&gt;%\n  add_binary_decisions() %&gt;%\n  add_default_solver(verbose = FALSE)\n\nThen, we solve the prioritization using solve.ConservationProblem().\n\ndat_soln &lt;- dat_problem %&gt;%\n  solve.ConservationProblem()\n\nAnd there you have it, you have generated a spatial prioritization! “Solving” the conservation “problem” is a bit anticlimactic, but this shows that most of the work to generate a spatial prioritization is to preprocess and wrangle the spatial data.\nIf you want to save the output for later use, you can do this in the normal way for R.\n\nsaveRDS(dat_soln, file.path(\"Output\", \"Solution1.rds\"))\n\nLet us plot the solution and see what it looks like.\n\n# Plot solution with a function we have defined (i.e., it is not in prioritizr)\n# This makes a prettier plot than using the default plot function in prioritizr\n(gg_sol &lt;- splnr_plot_Solution(dat_soln))\n\nWarning: Duplicated `override.aes` is ignored.\n\n\n\n\n\n\n\n\n\nHow well were targets met?\n\ntarg_coverage &lt;- eval_target_coverage_summary(dat_problem, dat_soln[, \"solution_1\"])"
  },
  {
    "objectID": "notes.html#irreplaceability",
    "href": "notes.html#irreplaceability",
    "title": "Conservation Planning for the Marine Environment",
    "section": "Irreplaceability",
    "text": "Irreplaceability\nSo far, our solution provides information which PUs should be selected to solve the defined conservation problem, so by meeting the targets for the features whilst minimizing the cost. However, some PUs might be more important in contributing to meeting the targets of the features than others. This concept is known as Irreplaceability and essentially measures the value of PUs to achieve the conservation objectives, considering the alternatives.\nPrioritizr has three built-in irreplaceability scores that can be applied to the solution to assess the importance of PUs: The Ferrier score, the rarity weighted richness score and the replacement cost score. We have provided code for running all of them, but we will only show the Ferrier score in this workshop, as it is relatively quick to run. Note that this score only works for conservation problems that include targets in their objective and have a single zone.\n\nsoln &lt;- dat_soln %&gt;%\n  as_tibble()\n\n# Ferrier score\nferrier &lt;- eval_ferrier_importance(dat_problem, soln[, \"solution_1\"]) %&gt;%\n  select(\"total\") %&gt;%\n  mutate(geometry = dat_soln$geometry) %&gt;%\n  rename(score = \"total\") %&gt;%\n  st_as_sf()\n\nWe won’t run these today, but the other two irreplaceability scores are shown here.\n\n# Rarity weighted richness\nrwr &lt;- eval_rare_richness_importance(dat_problem, soln[, \"solution_1\"]) %&gt;%\n  mutate(geometry = soln$geometry) %&gt;%\n  rename(score = \"rwr\") %&gt;%\n  st_as_sf()\n\n# Replacement cost\nreplacement &lt;- eval_replacement_importance(dat_problem, soln[, \"solution_1\"]) %&gt;%\n  mutate(geometry = soln$geometry) %&gt;%\n  drename(score = \"rc\") %&gt;%\n  st_as_sf()\n\nWe can visualise the Ferrier score across the planning domain:\n\n#prep data to allow to see the results better\nquant99fs &lt;- round(stats::quantile(ferrier$score, 0.99), 4)\nferrier$score[ferrier$score &gt;= quant99fs] &lt;- quant99fs\n\n# plot results\nggplot() +\n  geom_sf(data = ferrier, aes(fill = .data$score), colour = NA)\n\n\n\n\n\n\n\n\nWe can see that the majority of PUs has a very low Ferrier score. This means that according to the Ferrier score these PUs are less important than other PUs in terms of meeting all the targets for all features. In contrast, ome PUs in the center of the planning region have a comparably high Ferrier score. This means that not selecting these PUs in the solution would for example require several other PUs for contributing to the targets similarly."
  },
  {
    "objectID": "notes.html#selection-frequency",
    "href": "notes.html#selection-frequency",
    "title": "Conservation Planning for the Marine Environment",
    "section": "Selection frequency",
    "text": "Selection frequency\nThe algorithm that used to solve conservation problems in prioritizr (integer linear programming), can find optimal solutions to problems. In Marxan, this is not the case, and therefore the term selection frequency is found commonly across literature and practice. The selection frequency represents how many times a PU was selected across a range of solutions, thereby refelecting the importance of PU when meeting targets, but also allowing to explore alternative solutions that might be complementary. In prioritizr, we can also explore the selection frequency by using portfolios.\nThere are several different portfolio types available in prioritizr. Here, we use add_cuts_portfolio(), which allows to set the number of attempts to generate a different solution. A solution is excluded from the possible solutions to problem after it has previously obtained.\n\ndat_soln_portfolio &lt;- dat_problem %&gt;%\n  add_cuts_portfolio(5) %&gt;% # create a portfolio of solutions\n  solve.ConservationProblem()\n\nWe can now summarize the results to calculate the selection frequency across the 5 attempts and visualize the results.\n\nselFreq &lt;- dat_soln_portfolio %&gt;% # calculate selection frequency\n  st_drop_geometry() %&gt;%\n  mutate(selFreq = as.factor(rowSums(\n   select(., starts_with(\"solution_\"))\n  ))) %&gt;%\n  st_as_sf(geometry = dat_soln_portfolio$geometry) %&gt;%\n  select(selFreq)\n\nggplot() +\n  geom_sf(data = selFreq, aes(fill = .data$selFreq), colour = NA)\n\n\n\n\n\n\n\n\nWe can see that the majority of PUs have never been selected, some have been selected a few times, and some PUs have even been selected every time. This means these PUs are very important to meet the targets for the features."
  },
  {
    "objectID": "notes.html#preliminaries",
    "href": "notes.html#preliminaries",
    "title": "Conservation Planning for the Marine Environment",
    "section": "Preliminaries",
    "text": "Preliminaries\n\n# Extract feature names\n\ncol_name &lt;- features %&gt;%\n  select(-\"cellID\") %&gt;%\n  st_drop_geometry() %&gt;%\n  colnames()\n\n# Create targets object\n\n# Assign higher target for species with tracking data\ntargets &lt;- data.frame(feature = col_name) %&gt;%\n  mutate(Category = c(rep(\"Geomorphic\", 12), rep(\"Tracking Data\", 5))) %&gt;%\n  mutate(target = if_else(Category == \"Tracking Data\", 50 / 100, 5 / 100))"
  },
  {
    "objectID": "notes.html#create-the-basic-conservation-problem",
    "href": "notes.html#create-the-basic-conservation-problem",
    "title": "Conservation Planning for the Marine Environment",
    "section": "Create the basic conservation problem",
    "text": "Create the basic conservation problem\nSet up conservation problem.\n\ndatEx_problem &lt;- problem(out_sf,\n                         features = col_name,\n                         cost_column = \"cost\"\n) %&gt;%\n  add_min_set_objective() %&gt;% # Add objective function\n  add_relative_targets(targets$target) %&gt;% # specify the column with targets\n  add_binary_decisions() %&gt;% # Binary answer (Yes/No)\n  add_default_solver(verbose = FALSE) # Add solver\n\n# Solve conservation problem\ndatEx_soln &lt;- datEx_problem %&gt;%\n  solve.ConservationProblem() # Solve the problem\n\nPlotting the solution\n\n(gg_soln &lt;- splnr_plot_Solution(datEx_soln) +\n   geom_sf(data = landmass, colour = \"black\", fill = \"black\", show.legend = FALSE) +\n   coord_sf(xlim = st_bbox(PUs)$xlim, ylim = st_bbox(PUs)$ylim))\n\nCoordinate system already present. Adding new coordinate system, which will\nreplace the existing one.\n\n\nWarning: Duplicated `override.aes` is ignored.\n\n\n\n\n\n\n\n\n\n\n# How were the targets met?\ntargetsMet &lt;- eval_feature_representation_summary(\n  datEx_problem, \n  datEx_soln[, \"solution_1\"])\n\nThere were a lot of individual PUs selected in the solution. This can be problematic to include in an actual protected area"
  },
  {
    "objectID": "notes.html#adding-penalties",
    "href": "notes.html#adding-penalties",
    "title": "Conservation Planning for the Marine Environment",
    "section": "Adding Penalties",
    "text": "Adding Penalties\nPenalties can be added to the conservation problem as a way to penalize solutions according to a certain metric. Penalizing certain criteria (e.g. certain environmental conditions, activities etc.) leads to a trade-off in the objective function, which aims to minimise the cost. Increasing the “cost” of a planning units through a penalty causes planning units that are not penalized to be selected over those that are.\n\nPenalty 1: Boundary penalty\nThe boundary penalty helps the user decide how “clumped” the network should be. Often, it is not feasible to enforce a network of fragmented protected areas (as often happens when we optimize with no design constraints). For this reason, we need to adjust the boundary penalty to ensure we can minimize fragmentation and aggregate planning units into patches or clumps. There is no perfect value for the boundary penalty so we encourage users to explore different levels to see the effect.\nSet up conservation problem.\n\ndatEx_problem_P &lt;- problem(out_sf,\n                           features = col_name,\n                           cost_column = \"cost\"\n) %&gt;%\n  add_min_set_objective() %&gt;%\n  add_relative_targets(targets$target) %&gt;%\n  add_boundary_penalties(0.5) %&gt;%\n  add_binary_decisions() %&gt;%\n  add_default_solver(gap = 0.5, verbose = FALSE) # Larger optimality gap to speed up code\n\nSolve conservation problem.\n\ndatEx_soln_P &lt;- datEx_problem_P %&gt;%\n  solve.ConservationProblem()\n\n\n(gg_solnP &lt;- splnr_plot_Solution(datEx_soln_P) +\n   geom_sf(data = landmass, \n           colour = \"black\", fill = \"black\", show.legend = FALSE) +\n   coord_sf(xlim = st_bbox(PUs)$xlim, ylim = st_bbox(PUs)$ylim))\n\nCoordinate system already present. Adding new coordinate system, which will\nreplace the existing one.\n\n\nWarning: Duplicated `override.aes` is ignored.\n\n\n\n\n\n\n\n\n\nThe selected PUs are more aggregated BUT, in an example with varying cost this might also lead to a more expensive solution\n\n\nPenalty 2: Linear penalty\nAnother type of penalty is the linear penalty . The linear penalty assumes a linear trade-off between the penalty values and the primary objective of the conservation planning problem (e.g., solution cost for minimum set problems). In our example, we will now set up a conservation problem that uses an area-based primary cost and we will use the fishing information as a penalty, so that selecting values with a high cost are penalized.\n\n# Add another cost for area\nout_sf &lt;- out_sf %&gt;%\n  mutate(cost_area = rep(1, nrow(.)))\n\nSet up conservation problem.\n\ndatEx_problem_linP &lt;- problem(out_sf,\n                           features = col_name,\n                           cost_column = \"cost_area\") %&gt;%\n  add_linear_penalties(10, data = \"cost\") %&gt;%\n  add_min_set_objective() %&gt;%\n  add_relative_targets(targets$target) %&gt;%\n  add_binary_decisions() %&gt;%\n  add_default_solver(gap = 0.2, verbose = FALSE) # we're adjusting the optimality gap here to speed up the process\n\nSolve conservation problem.\n\ndatEx_soln_linP &lt;- datEx_problem_linP %&gt;%\n  solve.ConservationProblem()\n\n\n(gg_solnlinP &lt;- splnr_plot_Solution(datEx_soln_linP) +\n    geom_sf(data = landmass, colour = \"black\", fill = \"black\", show.legend = FALSE) +\n    coord_sf(xlim = st_bbox(PUs)$xlim, ylim = st_bbox(PUs)$ylim))\n\nCoordinate system already present. Adding new coordinate system, which will\nreplace the existing one.\n\n\nWarning: Duplicated `override.aes` is ignored.\n\n\n\n\n\n\n\n\n\nThere are several types of penalties, so it is worthwhile browsing through the prioritizr Reference tab for more information."
  },
  {
    "objectID": "notes.html#adding-constraints",
    "href": "notes.html#adding-constraints",
    "title": "Conservation Planning for the Marine Environment",
    "section": "Adding Constraints",
    "text": "Adding Constraints\nThe conservation problems so far were relatively simple. In reality, it is often required to add more complexity. A constraint can be added to a conservation planning problem to ensure that solutions exhibit a specific characteristic.\n\nConstraint 1: Locked-in areas\nOne example for constraints is locking in specific areas, for example already existing MPAs. These MPA will have to be part of the final solution - after all, they are locked-in.\n\nmpas &lt;- readRDS(file.path(inputDat, \"MPAs\", \"mpas.rds\"))\n\n# First look at the data\n(gg_mpas &lt;- ggplot() +\n    geom_sf(data = mpas, aes(fill = .data$mpas), \n            colour = NA, size = 0.001, show.legend = FALSE))\n\n\n\n\n\n\n\n\nThe conservation problem.\n\ndatEx_problem_LIC &lt;- problem(out_sf,\n                             features = col_name,\n                             cost_column = \"cost\"\n) %&gt;%\n  add_min_set_objective() %&gt;%\n  add_relative_targets(targets$target) %&gt;%\n  add_locked_in_constraints(as.logical(mpas$mpas)) %&gt;%\n  add_binary_decisions() %&gt;%\n  add_default_solver(verbose = FALSE)\n\n# Solve conservation problem\ndatEx_soln_LIC &lt;- datEx_problem_LIC %&gt;%\n  solve.ConservationProblem()\n\n(gg_solnLIC &lt;- splnr_plot_Solution(datEx_soln_LIC) +\n    geom_sf(data = landmass, \n            colour = \"black\", fill = \"black\", show.legend = FALSE) +\n    coord_sf(xlim = st_bbox(PUs)$xlim, ylim = st_bbox(PUs)$ylim))\n\nCoordinate system already present. Adding new coordinate system, which will\nreplace the existing one.\n\n\nWarning: Duplicated `override.aes` is ignored.\n\n\n\n\n\n\n\n\n\n\n\nConstraint 2: Linear Constraints\nLinear constraints can be used to ensure that solutions meet certain criteria. For example, linear constraints can be used to add multiple budgets or to ensure that the total number of planning units allocated to a certain administrative area (e.g., a bioregion) does not exceed a certain threshold (e.g., 30% of its total area).\n\n# Set up conservation problem\ndatEx_problem_LC &lt;- problem(out_sf,\n                            features = col_name,\n                            cost_column = \"cost\"\n) %&gt;%\n  add_min_set_objective() %&gt;%\n  add_relative_targets(targets$target) %&gt;%\n  add_linear_constraints(sum(out_sf$cost_area) * 0.4, \n                         sense = \"&lt;=\", out_sf$cost_area) %&gt;% # set area-based budget\n  add_binary_decisions() %&gt;%\n  add_default_solver(verbose = FALSE)\n\n# Solve conservation problem\ndatEx_soln_LC &lt;- datEx_problem_LC %&gt;%\n  solve.ConservationProblem()\n\n(gg_solnLC &lt;- splnr_plot_Solution(datEx_soln_LC) +\n    geom_sf(data = landmass, \n            colour = \"black\", fill = \"black\", show.legend = FALSE) +\n    coord_sf(xlim = st_bbox(PUs)$xlim, ylim = st_bbox(PUs)$ylim))\n\nCoordinate system already present. Adding new coordinate system, which will\nreplace the existing one.\n\n\nWarning: Duplicated `override.aes` is ignored.\n\n\n\n\n\n\n\n\n\nThere are several types of constraints, so it is worthwhile browsing through the prioritizr Reference tab for more information."
  },
  {
    "objectID": "notes.html#changing-objective-functions",
    "href": "notes.html#changing-objective-functions",
    "title": "Conservation Planning for the Marine Environment",
    "section": "Changing Objective Functions",
    "text": "Changing Objective Functions\nAn objective is used to specify the overall goal of a conservation planning problem. All conservation planning problems involve minimizing or maximizing an objective.\n\nObjective 1: Minimum set\nThe minimum set objective in a conservation planning problem minimizes the cost of the solution whilst ensuring that all targets are met. This objective is similar to the one used in Marxan.\n\n# Targets\ndfTarget &lt;- splnr_get_featureRep(datEx_soln, datEx_problem,\n                                 solnCol = \"solution_1\"\n) %&gt;%\n  mutate(category = targets$Category)\n\n(ggTarget &lt;- splnr_plot_featureRep(\n  df = dfTarget,\n  nr = 1, showTarget = TRUE\n))\n\n\n\n\n\n\n\n\n\n\nObjective 2: Minimum shortfall\nThe aim of the minimum shortfall objective is to find the set of planning units that minimizes the overall (weighted sum) shortfall for the representation targets. This minimizes the fraction of each target that remains unmet, for as many features as possible while staying within a fixed budget.\n\n# Set up conservation problem\ndatEx_problem_minS &lt;- problem(out_sf,\n                              features = col_name,\n                              cost_column = \"cost_area\"\n) %&gt;%\n  add_min_shortfall_objective(sum(out_sf$cost_area) * 0.05) %&gt;%\n  add_relative_targets(targets$target) %&gt;% # specify column with targets\n  add_binary_decisions() %&gt;%\n  add_default_solver(verbose = FALSE)\n\n# Solve conservation problem\ndatEx_soln_minS &lt;- datEx_problem_minS %&gt;%\n  solve.ConservationProblem()\n\n(gg_solnminS &lt;- splnr_plot_Solution(datEx_soln_minS) +\n    geom_sf(data = landmass, \n            colour = \"black\", fill = \"black\", show.legend = FALSE) +\n    coord_sf(xlim = st_bbox(PUs)$xlim, ylim = st_bbox(PUs)$ylim))\n\nCoordinate system already present. Adding new coordinate system, which will\nreplace the existing one.\n\n\nWarning: Duplicated `override.aes` is ignored.\n\n\n\n\n\n\n\n\n# Feature representation\ndfTarget_minS &lt;- splnr_get_featureRep(datEx_soln_minS, datEx_problem_minS,\n                                      solnCol = \"solution_1\"\n) %&gt;%\n  mutate(category = targets$Category)\n\n(ggTargetminS &lt;- splnr_plot_featureRep(\n  df = dfTarget_minS,\n  nr = 1, showTarget = TRUE\n))\n\n\n\n\n\n\n\n\nCompare objective functions\n\n(ggTarget_comparison &lt;- ggTarget + ggTargetminS +\n   plot_layout(guides = \"collect\", axes = \"collect\"))\n\n\n\n\n\n\n\n\n\n\nObjective 3: Maximum utility\n\ndatEx_problem_maxU &lt;- problem(out_sf,\n                              features = col_name,\n                              cost_column = \"cost_area\"\n) %&gt;%\n  add_max_utility_objective(sum(out_sf$cost_area) * 0.05) %&gt;%\n  add_binary_decisions() %&gt;%\n  add_default_solver(verbose = FALSE)\n\n# Solve conservation problem\ndatEx_soln_maxU &lt;- datEx_problem_maxU %&gt;%\n  solve.ConservationProblem()\n\n(gg_solnmaxU &lt;- splnr_plot_Solution(datEx_soln_maxU) +\n    geom_sf(data = landmass, \n            colour = \"black\", fill = \"black\", show.legend = FALSE) +\n    coord_sf(xlim = st_bbox(PUs)$xlim, ylim = st_bbox(PUs)$ylim))\n\nCoordinate system already present. Adding new coordinate system, which will\nreplace the existing one.\n\n\nWarning: Duplicated `override.aes` is ignored.\n\n\n\n\n\n\n\n\ndfTarget_maxU &lt;- splnr_get_featureRep(datEx_soln_maxU, datEx_problem_maxU,\n                                      solnCol = \"solution_1\",\n                                      maxUtility = TRUE\n) %&gt;%\n  mutate(category = targets$Category)\n\n(ggTargetmaxU &lt;- splnr_plot_featureRep(\n  df = dfTarget_maxU,\n  nr = 1, showTarget = FALSE,\n  maxUtility = TRUE\n))\n\n\n\n\n\n\n\n\nWe can compare the maximum utility objective function with the minimum set and minimum shortfall objectives.\n\n(ggTarget_comparison2 &lt;- ggTarget + ggTargetminS + ggTargetmaxU +\n   plot_layout(guides = \"collect\", axes = \"collect\"))"
  },
  {
    "objectID": "notes.html#adding-zones",
    "href": "notes.html#adding-zones",
    "title": "Conservation Planning for the Marine Environment",
    "section": "Adding Zones",
    "text": "Adding Zones\nMany real-world conservation problems do not simply involve deciding if an area should be protected or not. In reality, many problems involve a range of different types of management and the goal is to determine which areas should be allocated to which type of management. We can construct such a conservation problem to have different management zones, using the function zones().\n\n# Create Targets\ntargetsZones &lt;- data.frame(feature = col_name) %&gt;%\n  mutate(Category = c(rep(\"Geomorphic\", 12), rep(\"Tracking Data\", 5))) %&gt;%\n  mutate(\n    targetZ1 = dplyr::if_else(Category == \"Tracking Data\", 30 / 100, 0),\n    targetZ2 = dplyr::if_else(Category != \"Tracking Data\", 10 / 100, 0)\n  ) %&gt;%\n  dplyr::select(\"targetZ1\", \"targetZ2\") %&gt;%\n  as.matrix()\n\n# Create zones object\nz1 &lt;- prioritizr::zones(\"zone 1\" = col_name, \"zone 2\" = col_name)\n\n# Set up conservation problem\n# NOTE: when using sf input, we need as many cost columns as we have zones\ndatEx_problem_zones &lt;- prioritizr::problem(\n  out_sf %&gt;%\n    mutate(\n      Cost1 = rep(1, nrow(.)),\n      Cost2 = rep(1, nrow(.))\n    ),\n  z1,\n  cost_column = c(\"Cost1\", \"Cost2\")\n) %&gt;%\n  prioritizr::add_min_set_objective() %&gt;%\n  prioritizr::add_relative_targets(targetsZones) %&gt;%\n  prioritizr::add_binary_decisions() %&gt;%\n  prioritizr::add_default_solver(verbose = FALSE)\n\n# Solve conservation problem\ndatEx_soln_zones &lt;- datEx_problem_zones %&gt;%\n  prioritizr::solve.ConservationProblem()\n\nWe can examine the solution.\n\n(gg_soln_zones &lt;- splnr_plot_Solution(\n  datEx_soln_zones,\n  zones = TRUE,\n  colorVals = c(\"#c6dbef\", \"#3182bd\", \"#003366\"),\n  legendLabels = c(\"Not selected\", \"Zone 1\", \"Zone 2\")\n) +\n  geom_sf(data = landmass, \n          colour = \"black\", fill = \"lightgrey\", show.legend = FALSE) +\n  coord_sf(xlim = st_bbox(PUs)$xlim, ylim = st_bbox(PUs)$ylim))\n\nCoordinate system already present. Adding new coordinate system, which will\nreplace the existing one.\n\n\nWarning: Duplicated `override.aes` is ignored.\n\n\n\n\n\n\n\n\n# Feature representation\ntargetsMet_zones &lt;- datEx_soln_zones %&gt;%\n  dplyr::select(tidyselect::starts_with(c(\"solution\"))) %&gt;%\n  sf::st_drop_geometry() %&gt;%\n  tibble::as_tibble() %&gt;%\n  prioritizr::eval_feature_representation_summary(datEx_problem_zones, .)\n\n\n\n\n\n\n\nBeyond code - Apps and communication\n\n\n\nOpening up conservation planning to a wider audience: communicating results effectively and transparently to stakeholders and managers using R Shiny Apps and MaPP"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Us",
    "section": "",
    "text": "Sandra Neubert\nSandra Neubert is a data scientist with an interest in spatial planning and ecosystem modelling. She is currently undertaking a PhD in multiple-use spatial planning in the Global South, as part of a collaborative project between the University of Queensland and the University of Exeter. Her research aims to explore how human activities in the marine environment can be effectively integrated into conservation planning to optimize benefits while minimizing the associated costs for both conservation and sustainable use.\nSandra’s experience also includes writing R packages for time-efficient and reproducible spatial planning and Shiny apps to facilitate stakeholder engagement. She is involved in creating tools for multiple projects focused on protected area design, including in the Weddell Sea (Southern Ocean) and across various Indo-Pacific island nations.\n\n\nProfessor Anthony Richardson\nProfessor Anthony J. Richardson uses mathematical, statistical, computational and spatial planning tools to investigate human impacts on our oceans - and to find solutions. Particular foci include: Marine spatial planning (where best to locate marine protected areas), Developing models of marine ecosystems (how plankton regulate fisheries productivity and carbon sequestration) and, long-term change in marine plankton.\nAnthony holds a joint position between the School of the Environment at UQ and CSIRO Environment, Australia’s national science provider. Anthony runs a dynamic lab at the nexus between marine ecology, conservation science and mathematics. His focus is on using mathematical tools to better conserve biodiversity, predict impacts of climate change, and understand the functioning of marine ecosystems.\n\n\nDr Jason Everett\nDr Jason Everett is a biological oceanographer and data scientist. He works on understanding how oceanographic processes structure global pelagic food webs, designing climate-smart marine protected areas, and investigating the impact of climate-change on marine ecosystem function. He enjoys working with model output, including oceanographic, climate and size-spectra, and collating large observational datasets to analyse.\nRecently Jason has been building R-packages and R-shiny visualisation tools and applying novel spatial planning methods to inform marine spatial management. He is currently working on tools for on-the-ground deployment in the Weddell Sea (Antarctica) and various island nations of the Pacific, Indian and Atlantic Oceans.\nThe latest tools released are the Biological Ocean Observer, in conjunction with the r-package planktonr.\n\n\nDr Jennifer McGowan\nDr Jennifer McGowan uses aspects of spatial ecology, economics, operations research and decision theory to help managers and practitioners make transparent, repeatable and robust decisions about the allocation of resources to inform conservation actions on the ground. She applies these skills at global and local scales to help solve a wide array of conservation challenges, from optimizing protected area network design to prioritizing countries for conservation finance initiatives to deliver return-on-investment benefits from biodiversity protection. She also invests significant time into teaching conservation planning theory and training to build capacity in governments, universities and NGOs to embrace systematic conservation planning in their biodiversity and climate adaptation strategies. Jennifer is dedicated to help get decision-support tools into the hands of the people that need them and build institutional knowledge in governments and NGOs who are working hard to save biodiversity and livelihoods on the ground."
  },
  {
    "objectID": "mapp.html",
    "href": "mapp.html",
    "title": "The Marxan Planning Platform",
    "section": "",
    "text": "There is a copy of the Galapogas Tutorial in your workshop notes .zip file. Alternatively you can download it from here."
  }
]